// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: auth.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearUserOTP = `-- name: ClearUserOTP :exec
UPDATE users
SET otp = NULL,
    otp_expires_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ClearUserOTP(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearUserOTP, id)
	return err
}

const clearUserOTPInTenant = `-- name: ClearUserOTPInTenant :exec
UPDATE users
SET otp = NULL,
    otp_expires_at = NULL,
    updated_at = NOW()
WHERE tenant_id = $1 AND id = $2
`

type ClearUserOTPInTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) ClearUserOTPInTenant(ctx context.Context, arg ClearUserOTPInTenantParams) error {
	_, err := q.db.Exec(ctx, clearUserOTPInTenant, arg.TenantID, arg.ID)
	return err
}

const clearVerificationToken = `-- name: ClearVerificationToken :exec
UPDATE users
SET verification_token = NULL
WHERE id = $1 AND tenant_id = $2
`

type ClearVerificationTokenParams struct {
	ID       uuid.UUID   `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ClearVerificationToken(ctx context.Context, arg ClearVerificationTokenParams) error {
	_, err := q.db.Exec(ctx, clearVerificationToken, arg.ID, arg.TenantID)
	return err
}

const countSessionsByTenant = `-- name: CountSessionsByTenant :one
SELECT COUNT(*) as session_count
FROM sessions
WHERE tenant_id = $1
`

func (q *Queries) CountSessionsByTenant(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSessionsByTenant, tenantID)
	var session_count int64
	err := row.Scan(&session_count)
	return session_count, err
}

const countUsersByTenant = `-- name: CountUsersByTenant :one
SELECT COUNT(*) as user_count
FROM users
WHERE tenant_id = $1
`

func (q *Queries) CountUsersByTenant(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByTenant, tenantID)
	var user_count int64
	err := row.Scan(&user_count)
	return user_count, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, session_token, csrf_token, user_agent, ip, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, session_token, csrf_token, user_agent, ip, created_at, expires_at, tenant_id
`

type CreateSessionParams struct {
	UserID       uuid.UUID `json:"user_id"`
	SessionToken string    `json:"session_token"`
	CsrfToken    string    `json:"csrf_token"`
	UserAgent    string    `json:"user_agent"`
	Ip           string    `json:"ip"`
	ExpiresAt    time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.SessionToken,
		arg.CsrfToken,
		arg.UserAgent,
		arg.Ip,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.CsrfToken,
		&i.UserAgent,
		&i.Ip,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.TenantID,
	)
	return i, err
}

const createSessionInTenant = `-- name: CreateSessionInTenant :one

INSERT INTO sessions (tenant_id, user_id, session_token, csrf_token, user_agent, ip, expires_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, session_token, csrf_token, user_agent, ip, created_at, expires_at, tenant_id
`

type CreateSessionInTenantParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	UserID       uuid.UUID   `json:"user_id"`
	SessionToken string      `json:"session_token"`
	CsrfToken    string      `json:"csrf_token"`
	UserAgent    string      `json:"user_agent"`
	Ip           string      `json:"ip"`
	ExpiresAt    time.Time   `json:"expires_at"`
}

// Tenant-aware session queries
func (q *Queries) CreateSessionInTenant(ctx context.Context, arg CreateSessionInTenantParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSessionInTenant,
		arg.TenantID,
		arg.UserID,
		arg.SessionToken,
		arg.CsrfToken,
		arg.UserAgent,
		arg.Ip,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.CsrfToken,
		&i.UserAgent,
		&i.Ip,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.TenantID,
	)
	return i, err
}

const createTenant = `-- name: CreateTenant :one
INSERT INTO tenants (name, domain, subdomain, api_key, settings)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, domain, subdomain, api_key, settings, is_active, created_at, updated_at
`

type CreateTenantParams struct {
	Name      string      `json:"name"`
	Domain    string      `json:"domain"`
	Subdomain pgtype.Text `json:"subdomain"`
	ApiKey    string      `json:"api_key"`
	Settings  []byte      `json:"settings"`
}

func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, createTenant,
		arg.Name,
		arg.Domain,
		arg.Subdomain,
		arg.ApiKey,
		arg.Settings,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Subdomain,
		&i.ApiKey,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithOtp = `-- name: CreateUserWithOtp :one
INSERT INTO users (id, email, otp, otp_expires_at, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, NOW(), NOW())
RETURNING id, email, password_hash, otp, otp_expires_at, email_verified, verification_token, created_at, updated_at, tenant_id
`

type CreateUserWithOtpParams struct {
	Email        string             `json:"email"`
	Otp          pgtype.Text        `json:"otp"`
	OtpExpiresAt pgtype.Timestamptz `json:"otp_expires_at"`
}

func (q *Queries) CreateUserWithOtp(ctx context.Context, arg CreateUserWithOtpParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithOtp, arg.Email, arg.Otp, arg.OtpExpiresAt)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Otp,
		&i.OtpExpiresAt,
		&i.EmailVerified,
		&i.VerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const createUserWithOtpInTenant = `-- name: CreateUserWithOtpInTenant :one
INSERT INTO users (id, tenant_id, email, otp, otp_expires_at, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, $4, NOW(), NOW())
RETURNING id, email, password_hash, otp, otp_expires_at, email_verified, verification_token, created_at, updated_at, tenant_id
`

type CreateUserWithOtpInTenantParams struct {
	TenantID     pgtype.UUID        `json:"tenant_id"`
	Email        string             `json:"email"`
	Otp          pgtype.Text        `json:"otp"`
	OtpExpiresAt pgtype.Timestamptz `json:"otp_expires_at"`
}

func (q *Queries) CreateUserWithOtpInTenant(ctx context.Context, arg CreateUserWithOtpInTenantParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithOtpInTenant,
		arg.TenantID,
		arg.Email,
		arg.Otp,
		arg.OtpExpiresAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Otp,
		&i.OtpExpiresAt,
		&i.EmailVerified,
		&i.VerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const createUserWithPassword = `-- name: CreateUserWithPassword :one
INSERT INTO users (id, email, password_hash, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, NOW(), NOW())
RETURNING id, email, password_hash, otp, otp_expires_at, email_verified, verification_token, created_at, updated_at, tenant_id
`

type CreateUserWithPasswordParams struct {
	Email        string      `json:"email"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) CreateUserWithPassword(ctx context.Context, arg CreateUserWithPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithPassword, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Otp,
		&i.OtpExpiresAt,
		&i.EmailVerified,
		&i.VerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const createUserWithPasswordInTenant = `-- name: CreateUserWithPasswordInTenant :one
INSERT INTO users (id, tenant_id, email, password_hash, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, NOW(), NOW())
RETURNING id, email, password_hash, otp, otp_expires_at, email_verified, verification_token, created_at, updated_at, tenant_id
`

type CreateUserWithPasswordInTenantParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	Email        string      `json:"email"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) CreateUserWithPasswordInTenant(ctx context.Context, arg CreateUserWithPasswordInTenantParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithPasswordInTenant, arg.TenantID, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Otp,
		&i.OtpExpiresAt,
		&i.EmailVerified,
		&i.VerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const deleteSessionByID = `-- name: DeleteSessionByID :execrows
DELETE FROM sessions
WHERE id = $1
`

func (q *Queries) DeleteSessionByID(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSessionByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSessionByIDAndTenant = `-- name: DeleteSessionByIDAndTenant :execrows
DELETE FROM sessions
WHERE tenant_id = $1 AND id = $2
`

type DeleteSessionByIDAndTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       int64       `json:"id"`
}

func (q *Queries) DeleteSessionByIDAndTenant(ctx context.Context, arg DeleteSessionByIDAndTenantParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSessionByIDAndTenant, arg.TenantID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSessionByUserID = `-- name: DeleteSessionByUserID :execrows
DELETE FROM sessions
WHERE user_id = $1
`

func (q *Queries) DeleteSessionByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSessionByUserID, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSessionByUserIDAndTenant = `-- name: DeleteSessionByUserIDAndTenant :execrows
DELETE FROM sessions
WHERE tenant_id = $1 AND user_id = $2
`

type DeleteSessionByUserIDAndTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   uuid.UUID   `json:"user_id"`
}

func (q *Queries) DeleteSessionByUserIDAndTenant(ctx context.Context, arg DeleteSessionByUserIDAndTenantParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSessionByUserIDAndTenant, arg.TenantID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSessionsByDevice = `-- name: DeleteSessionsByDevice :execrows
DELETE FROM sessions
WHERE user_id = $1 AND user_agent = $2 AND ip = $3
`

type DeleteSessionsByDeviceParams struct {
	UserID    uuid.UUID `json:"user_id"`
	UserAgent string    `json:"user_agent"`
	Ip        string    `json:"ip"`
}

func (q *Queries) DeleteSessionsByDevice(ctx context.Context, arg DeleteSessionsByDeviceParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSessionsByDevice, arg.UserID, arg.UserAgent, arg.Ip)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSessionsByDeviceAndTenant = `-- name: DeleteSessionsByDeviceAndTenant :execrows
DELETE FROM sessions
WHERE tenant_id = $1 AND user_id = $2 AND user_agent = $3 AND ip = $4
`

type DeleteSessionsByDeviceAndTenantParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	UserID    uuid.UUID   `json:"user_id"`
	UserAgent string      `json:"user_agent"`
	Ip        string      `json:"ip"`
}

func (q *Queries) DeleteSessionsByDeviceAndTenant(ctx context.Context, arg DeleteSessionsByDeviceAndTenantParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSessionsByDeviceAndTenant,
		arg.TenantID,
		arg.UserID,
		arg.UserAgent,
		arg.Ip,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTenantByID = `-- name: DeleteTenantByID :exec
DELETE FROM tenants
WHERE id = $1
`

func (q *Queries) DeleteTenantByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTenantByID, id)
	return err
}

const getCsrfTokenBySessionToken = `-- name: GetCsrfTokenBySessionToken :one
SELECT csrf_token FROM sessions
WHERE session_token = $1
LIMIT 1
`

func (q *Queries) GetCsrfTokenBySessionToken(ctx context.Context, sessionToken string) (string, error) {
	row := q.db.QueryRow(ctx, getCsrfTokenBySessionToken, sessionToken)
	var csrf_token string
	err := row.Scan(&csrf_token)
	return csrf_token, err
}

const getCsrfTokenBySessionTokenAndTenant = `-- name: GetCsrfTokenBySessionTokenAndTenant :one
SELECT csrf_token FROM sessions
WHERE tenant_id = $1 AND session_token = $2 AND expires_at > NOW()
LIMIT 1
`

type GetCsrfTokenBySessionTokenAndTenantParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	SessionToken string      `json:"session_token"`
}

func (q *Queries) GetCsrfTokenBySessionTokenAndTenant(ctx context.Context, arg GetCsrfTokenBySessionTokenAndTenantParams) (string, error) {
	row := q.db.QueryRow(ctx, getCsrfTokenBySessionTokenAndTenant, arg.TenantID, arg.SessionToken)
	var csrf_token string
	err := row.Scan(&csrf_token)
	return csrf_token, err
}

const getSessionByTokenAndTenant = `-- name: GetSessionByTokenAndTenant :one
SELECT id, tenant_id, user_id, session_token, csrf_token, user_agent, ip, expires_at, created_at
FROM sessions
WHERE tenant_id = $1 AND session_token = $2 AND expires_at > NOW()
LIMIT 1
`

type GetSessionByTokenAndTenantParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	SessionToken string      `json:"session_token"`
}

type GetSessionByTokenAndTenantRow struct {
	ID           int64       `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	UserID       uuid.UUID   `json:"user_id"`
	SessionToken string      `json:"session_token"`
	CsrfToken    string      `json:"csrf_token"`
	UserAgent    string      `json:"user_agent"`
	Ip           string      `json:"ip"`
	ExpiresAt    time.Time   `json:"expires_at"`
	CreatedAt    time.Time   `json:"created_at"`
}

func (q *Queries) GetSessionByTokenAndTenant(ctx context.Context, arg GetSessionByTokenAndTenantParams) (GetSessionByTokenAndTenantRow, error) {
	row := q.db.QueryRow(ctx, getSessionByTokenAndTenant, arg.TenantID, arg.SessionToken)
	var i GetSessionByTokenAndTenantRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SessionToken,
		&i.CsrfToken,
		&i.UserAgent,
		&i.Ip,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionRowBySessionToken = `-- name: GetSessionRowBySessionToken :one
SELECT id, user_id, session_token, csrf_token, user_agent, ip, created_at, expires_at, tenant_id FROM sessions
WHERE session_token = $1
LIMIT 1
`

func (q *Queries) GetSessionRowBySessionToken(ctx context.Context, sessionToken string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionRowBySessionToken, sessionToken)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.CsrfToken,
		&i.UserAgent,
		&i.Ip,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.TenantID,
	)
	return i, err
}

const getSessionsByUserID = `-- name: GetSessionsByUserID :many
SELECT id, user_id, session_token, csrf_token, user_agent, ip, created_at, expires_at, tenant_id FROM sessions
WHERE user_id = $1
`

func (q *Queries) GetSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]Session, error) {
	rows, err := q.db.Query(ctx, getSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionToken,
			&i.CsrfToken,
			&i.UserAgent,
			&i.Ip,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.TenantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsByUserIDAndTenant = `-- name: GetSessionsByUserIDAndTenant :many
SELECT id, tenant_id, user_id, session_token, csrf_token, user_agent, ip, expires_at, created_at
FROM sessions
WHERE tenant_id = $1 AND user_id = $2
`

type GetSessionsByUserIDAndTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   uuid.UUID   `json:"user_id"`
}

type GetSessionsByUserIDAndTenantRow struct {
	ID           int64       `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	UserID       uuid.UUID   `json:"user_id"`
	SessionToken string      `json:"session_token"`
	CsrfToken    string      `json:"csrf_token"`
	UserAgent    string      `json:"user_agent"`
	Ip           string      `json:"ip"`
	ExpiresAt    time.Time   `json:"expires_at"`
	CreatedAt    time.Time   `json:"created_at"`
}

func (q *Queries) GetSessionsByUserIDAndTenant(ctx context.Context, arg GetSessionsByUserIDAndTenantParams) ([]GetSessionsByUserIDAndTenantRow, error) {
	rows, err := q.db.Query(ctx, getSessionsByUserIDAndTenant, arg.TenantID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionsByUserIDAndTenantRow{}
	for rows.Next() {
		var i GetSessionsByUserIDAndTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.SessionToken,
			&i.CsrfToken,
			&i.UserAgent,
			&i.Ip,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantByAPIKey = `-- name: GetTenantByAPIKey :one
SELECT id, name, domain, subdomain, api_key, settings, is_active, created_at, updated_at
FROM tenants
WHERE api_key = $1 AND is_active = true
LIMIT 1
`

func (q *Queries) GetTenantByAPIKey(ctx context.Context, apiKey string) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByAPIKey, apiKey)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Subdomain,
		&i.ApiKey,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantByDomain = `-- name: GetTenantByDomain :one

SELECT id, name, domain, subdomain, api_key, settings, is_active, created_at, updated_at
FROM tenants
WHERE domain = $1 AND is_active = true
LIMIT 1
`

// Multi-tenant queries
func (q *Queries) GetTenantByDomain(ctx context.Context, domain string) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByDomain, domain)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Subdomain,
		&i.ApiKey,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT id, name, domain, subdomain, api_key, settings, is_active, created_at, updated_at
FROM tenants
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTenantByID(ctx context.Context, id uuid.UUID) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByID, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Subdomain,
		&i.ApiKey,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, otp, otp_expires_at, email_verified, verification_token, created_at, updated_at, tenant_id FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Otp,
		&i.OtpExpiresAt,
		&i.EmailVerified,
		&i.VerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const getUserByEmailAndTenant = `-- name: GetUserByEmailAndTenant :one

SELECT id, tenant_id, email, password_hash, otp, otp_expires_at, created_at, updated_at
FROM users
WHERE tenant_id = $1 AND email = $2
LIMIT 1
`

type GetUserByEmailAndTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Email    string      `json:"email"`
}

type GetUserByEmailAndTenantRow struct {
	ID           uuid.UUID          `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	Email        string             `json:"email"`
	PasswordHash pgtype.Text        `json:"password_hash"`
	Otp          pgtype.Text        `json:"otp"`
	OtpExpiresAt pgtype.Timestamptz `json:"otp_expires_at"`
	CreatedAt    time.Time          `json:"created_at"`
	UpdatedAt    time.Time          `json:"updated_at"`
}

// Tenant-aware user queries
func (q *Queries) GetUserByEmailAndTenant(ctx context.Context, arg GetUserByEmailAndTenantParams) (GetUserByEmailAndTenantRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmailAndTenant, arg.TenantID, arg.Email)
	var i GetUserByEmailAndTenantRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Otp,
		&i.OtpExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByIDAndTenant = `-- name: GetUserByIDAndTenant :one
SELECT id, tenant_id, email, password_hash, otp, otp_expires_at, created_at, updated_at
FROM users
WHERE tenant_id = $1 AND id = $2
LIMIT 1
`

type GetUserByIDAndTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       uuid.UUID   `json:"id"`
}

type GetUserByIDAndTenantRow struct {
	ID           uuid.UUID          `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	Email        string             `json:"email"`
	PasswordHash pgtype.Text        `json:"password_hash"`
	Otp          pgtype.Text        `json:"otp"`
	OtpExpiresAt pgtype.Timestamptz `json:"otp_expires_at"`
	CreatedAt    time.Time          `json:"created_at"`
	UpdatedAt    time.Time          `json:"updated_at"`
}

func (q *Queries) GetUserByIDAndTenant(ctx context.Context, arg GetUserByIDAndTenantParams) (GetUserByIDAndTenantRow, error) {
	row := q.db.QueryRow(ctx, getUserByIDAndTenant, arg.TenantID, arg.ID)
	var i GetUserByIDAndTenantRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Otp,
		&i.OtpExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByVerificationTokenAndTenant = `-- name: GetUserByVerificationTokenAndTenant :one
SELECT id, tenant_id, email, password_hash, otp, otp_expires_at, created_at, updated_at, email_verified, verification_token
FROM users
WHERE tenant_id = $1 AND verification_token = $2
LIMIT 1
`

type GetUserByVerificationTokenAndTenantParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	VerificationToken pgtype.Text `json:"verification_token"`
}

type GetUserByVerificationTokenAndTenantRow struct {
	ID                uuid.UUID          `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	Email             string             `json:"email"`
	PasswordHash      pgtype.Text        `json:"password_hash"`
	Otp               pgtype.Text        `json:"otp"`
	OtpExpiresAt      pgtype.Timestamptz `json:"otp_expires_at"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	EmailVerified     pgtype.Bool        `json:"email_verified"`
	VerificationToken pgtype.Text        `json:"verification_token"`
}

func (q *Queries) GetUserByVerificationTokenAndTenant(ctx context.Context, arg GetUserByVerificationTokenAndTenantParams) (GetUserByVerificationTokenAndTenantRow, error) {
	row := q.db.QueryRow(ctx, getUserByVerificationTokenAndTenant, arg.TenantID, arg.VerificationToken)
	var i GetUserByVerificationTokenAndTenantRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Otp,
		&i.OtpExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailVerified,
		&i.VerificationToken,
	)
	return i, err
}

const getUserIDBySessionToken = `-- name: GetUserIDBySessionToken :one
SELECT user_id FROM sessions
WHERE session_token = $1
LIMIT 1
`

func (q *Queries) GetUserIDBySessionToken(ctx context.Context, sessionToken string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getUserIDBySessionToken, sessionToken)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserOTP = `-- name: GetUserOTP :one
SELECT otp, otp_expires_at
FROM users
WHERE id = $1
  AND otp IS NOT NULL
  AND otp_expires_at > NOW()
`

type GetUserOTPRow struct {
	Otp          pgtype.Text        `json:"otp"`
	OtpExpiresAt pgtype.Timestamptz `json:"otp_expires_at"`
}

func (q *Queries) GetUserOTP(ctx context.Context, id uuid.UUID) (GetUserOTPRow, error) {
	row := q.db.QueryRow(ctx, getUserOTP, id)
	var i GetUserOTPRow
	err := row.Scan(&i.Otp, &i.OtpExpiresAt)
	return i, err
}

const getUserOTPInTenant = `-- name: GetUserOTPInTenant :one
SELECT otp, otp_expires_at
FROM users
WHERE tenant_id = $1 AND id = $2
  AND otp IS NOT NULL
`

type GetUserOTPInTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       uuid.UUID   `json:"id"`
}

type GetUserOTPInTenantRow struct {
	Otp          pgtype.Text        `json:"otp"`
	OtpExpiresAt pgtype.Timestamptz `json:"otp_expires_at"`
}

func (q *Queries) GetUserOTPInTenant(ctx context.Context, arg GetUserOTPInTenantParams) (GetUserOTPInTenantRow, error) {
	row := q.db.QueryRow(ctx, getUserOTPInTenant, arg.TenantID, arg.ID)
	var i GetUserOTPInTenantRow
	err := row.Scan(&i.Otp, &i.OtpExpiresAt)
	return i, err
}

const listTenants = `-- name: ListTenants :many

SELECT id, name, domain, subdomain, api_key, settings, is_active, created_at, updated_at
FROM tenants
ORDER BY created_at DESC
`

// Additional tenant management queries
func (q *Queries) ListTenants(ctx context.Context) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listTenants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Domain,
			&i.Subdomain,
			&i.ApiKey,
			&i.Settings,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setUserOTP = `-- name: SetUserOTP :exec
UPDATE users
SET otp = $1,
    otp_expires_at = $2,
    updated_at = NOW()
WHERE id = $3
`

type SetUserOTPParams struct {
	Otp          pgtype.Text        `json:"otp"`
	OtpExpiresAt pgtype.Timestamptz `json:"otp_expires_at"`
	ID           uuid.UUID          `json:"id"`
}

func (q *Queries) SetUserOTP(ctx context.Context, arg SetUserOTPParams) error {
	_, err := q.db.Exec(ctx, setUserOTP, arg.Otp, arg.OtpExpiresAt, arg.ID)
	return err
}

const setUserOTPInTenant = `-- name: SetUserOTPInTenant :exec
UPDATE users
SET otp = $3,
    otp_expires_at = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type SetUserOTPInTenantParams struct {
	ID           uuid.UUID          `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	Otp          pgtype.Text        `json:"otp"`
	OtpExpiresAt pgtype.Timestamptz `json:"otp_expires_at"`
}

func (q *Queries) SetUserOTPInTenant(ctx context.Context, arg SetUserOTPInTenantParams) error {
	_, err := q.db.Exec(ctx, setUserOTPInTenant,
		arg.ID,
		arg.TenantID,
		arg.Otp,
		arg.OtpExpiresAt,
	)
	return err
}

const updateSessionToken = `-- name: UpdateSessionToken :exec
UPDATE sessions
SET session_token = $2,
    expires_at = $3
WHERE id = $1
`

type UpdateSessionTokenParams struct {
	ID           int64     `json:"id"`
	SessionToken string    `json:"session_token"`
	ExpiresAt    time.Time `json:"expires_at"`
}

func (q *Queries) UpdateSessionToken(ctx context.Context, arg UpdateSessionTokenParams) error {
	_, err := q.db.Exec(ctx, updateSessionToken, arg.ID, arg.SessionToken, arg.ExpiresAt)
	return err
}

const updateSessionTokenInTenant = `-- name: UpdateSessionTokenInTenant :exec
UPDATE sessions
SET session_token = $3,
    expires_at = $4
WHERE tenant_id = $1 AND id = $2
`

type UpdateSessionTokenInTenantParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	ID           int64       `json:"id"`
	SessionToken string      `json:"session_token"`
	ExpiresAt    time.Time   `json:"expires_at"`
}

func (q *Queries) UpdateSessionTokenInTenant(ctx context.Context, arg UpdateSessionTokenInTenantParams) error {
	_, err := q.db.Exec(ctx, updateSessionTokenInTenant,
		arg.TenantID,
		arg.ID,
		arg.SessionToken,
		arg.ExpiresAt,
	)
	return err
}

const updateTenant = `-- name: UpdateTenant :one
UPDATE tenants
SET name = $2,
    domain = $3,
    subdomain = $4,
    is_active = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, domain, subdomain, api_key, settings, is_active, created_at, updated_at
`

type UpdateTenantParams struct {
	ID        uuid.UUID   `json:"id"`
	Name      string      `json:"name"`
	Domain    string      `json:"domain"`
	Subdomain pgtype.Text `json:"subdomain"`
	IsActive  pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateTenant(ctx context.Context, arg UpdateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, updateTenant,
		arg.ID,
		arg.Name,
		arg.Domain,
		arg.Subdomain,
		arg.IsActive,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Subdomain,
		&i.ApiKey,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTenantSettings = `-- name: UpdateTenantSettings :exec
UPDATE tenants
SET settings = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateTenantSettingsParams struct {
	ID       uuid.UUID `json:"id"`
	Settings []byte    `json:"settings"`
}

func (q *Queries) UpdateTenantSettings(ctx context.Context, arg UpdateTenantSettingsParams) error {
	_, err := q.db.Exec(ctx, updateTenantSettings, arg.ID, arg.Settings)
	return err
}

const updateTenantStatus = `-- name: UpdateTenantStatus :exec
UPDATE tenants
SET is_active = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateTenantStatusParams struct {
	ID       uuid.UUID   `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateTenantStatus(ctx context.Context, arg UpdateTenantStatusParams) error {
	_, err := q.db.Exec(ctx, updateTenantStatus, arg.ID, arg.IsActive)
	return err
}

const updateUserEmailVerified = `-- name: UpdateUserEmailVerified :exec
UPDATE users
SET email_verified = $3
WHERE id = $1 AND tenant_id = $2
`

type UpdateUserEmailVerifiedParams struct {
	ID            uuid.UUID   `json:"id"`
	TenantID      pgtype.UUID `json:"tenant_id"`
	EmailVerified pgtype.Bool `json:"email_verified"`
}

func (q *Queries) UpdateUserEmailVerified(ctx context.Context, arg UpdateUserEmailVerifiedParams) error {
	_, err := q.db.Exec(ctx, updateUserEmailVerified, arg.ID, arg.TenantID, arg.EmailVerified)
	return err
}

const userExistsByEmail = `-- name: UserExistsByEmail :one
SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)
`

func (q *Queries) UserExistsByEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userExistsByEmailAndTenant = `-- name: UserExistsByEmailAndTenant :one
SELECT EXISTS(SELECT 1 FROM users WHERE tenant_id = $1 AND email = $2)
`

type UserExistsByEmailAndTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Email    string      `json:"email"`
}

func (q *Queries) UserExistsByEmailAndTenant(ctx context.Context, arg UserExistsByEmailAndTenantParams) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByEmailAndTenant, arg.TenantID, arg.Email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
